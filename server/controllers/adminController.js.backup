// server/controllers/adminController.    console.log(`‚úÖ Nouvel utilisateur cr√©√©: ${nom} ${prenom} (${role || "employee"})`);
    console.log(`üìß Email: ${email}`);
    console.log(`üîë Mot de passe temporaire: ${motDePasseTemporaire}`);
const prisma = require('../prisma/client');
const bcrypt = require('bcrypt');
const { genererMotDePasseListible } = require('../utils/passwordUtils');

const creerEmploye = async (req, res) => {
  const { email, nom, prenom, telephone, categorie, dateEmbauche, role } = req.body;

  console.log('üîç CR√âATION UTILISATEUR DEBUG:');
  console.log('- email:', email);
  console.log('- role re√ßu:', role);
  console.log('- role final:', role || "employee");

  try {
    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) {
      return res.status(400).json({ error: "Cet email est d√©j√† utilis√©." });
    }

    // G√©n√©ration mot de passe temporaire lisible
    const motDePasseTemporaire = genererMotDePasseListible();
    const hashedPassword = await bcrypt.hash(motDePasseTemporaire, 10);

    const nouvelEmploye = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        nom,
        prenom,
        telephone,
        categorie,
        dateEmbauche: dateEmbauche ? new Date(dateEmbauche) : null,
        role: role || "employee", // ‚úÖ Utilise le r√¥le envoy√© ou "employee" par d√©faut
        firstLoginDone: false,
        statut: "actif"
      },
    });

    console.log(`‚úÖ Nouvel employ√© cr√©√©: ${nom} ${prenom}`);
    console.log(`ÔøΩ Mot de passe temporaire: ${motDePasseTemporaire}`);

    res.status(201).json({
      message: "Employ√© cr√©√© avec succ√®s",
      user: { 
        id: nouvelEmploye.id,
        email: nouvelEmploye.email, 
        nom: nouvelEmploye.nom,
        prenom: nouvelEmploye.prenom,
        telephone: nouvelEmploye.telephone,
        categorie: nouvelEmploye.categorie,
        dateEmbauche: nouvelEmploye.dateEmbauche,
        role: nouvelEmploye.role,
        statut: nouvelEmploye.statut
      },
      motDePasseTemporaire: motDePasseTemporaire,
      instructions: "L'employ√© devra changer ce mot de passe lors de sa premi√®re connexion"
    });
  } catch (err) {
    console.error("Erreur cr√©ation employ√© :", err);
    res.status(500).json({ error: "Erreur serveur" });
  }
};

const supprimerEmploye = async (req, res) => {
  const employeId = parseInt(req.params.id);

  // Validation ID
  if (isNaN(employeId)) {
    return res.status(400).json({
      error: "ID invalide",
      code: "INVALID_ID",
      raw: req.params.id
    });
  }

  try {
    // V√©rifier si l'employ√© existe
    const employe = await prisma.user.findUnique({
      where: { id: employeId },
      include: {
        _count: { select: { conges: true, pointages: true, plannings: true, shifts: true } }
      }
    });

    if (!employe) {
      return res.status(404).json({ 
        error: "Employ√© non trouv√©",
        code: "NOT_FOUND",
        details: "L'employ√© que vous essayez de supprimer n'existe pas." 
      });
    }

    console.log(`Suppression employ√© ID ${employeId}. Relations:`, employe._count);

    await prisma.$transaction(async (tx) => {
      if (employe._count.conges) await tx.conge.deleteMany({ where: { userId: employeId } });
      if (employe._count.pointages) await tx.pointage.deleteMany({ where: { userId: employeId } });
      if (employe._count.plannings) await tx.planning.deleteMany({ where: { userId: employeId } });
      if (employe._count.shifts) await tx.shift.deleteMany({ where: { employeId } });
      await tx.user.delete({ where: { id: employeId } });
    });

    return res.status(200).json({ message: "Employ√© supprim√© avec succ√®s." });
  } catch (error) {
    // Logs d√©taill√©s
    console.error('Erreur suppression d√©taill√©e:', {
      code: error.code,
      name: error.name,
      message: error.message,
      meta: error.meta,
      stack: error.stack?.split('\n').slice(0,4).join('\n')
    });

    let status = 500;
    let errorMessage = "Erreur lors de la suppression de l'employ√©.";
    let code = error.code || 'UNKNOWN';

    if (code === 'P2025') { // Record not found
      status = 404; errorMessage = "Employ√© d√©j√† supprim√©.";
    } else if (code === 'P2003') { // FK constraint
      status = 400; errorMessage = "Impossible de supprimer: des donn√©es li√©es existent.";
    } else if (code === 'P2034') { // Transaction failed
      status = 500; errorMessage = "√âchec de transaction, r√©essayez.";
    }

    return res.status(status).json({
      error: errorMessage,
      code,
      details: error.meta || null,
      raw: error.message
    });
  }
};

const modifierEmploye = async (req, res) => {
  const { id } = req.params;
  const { email, nom, prenom } = req.body; // Ajoutez nom et prenom

  try {
    const updated = await prisma.user.update({
      where: { id: parseInt(id) },
      data: { 
        email,
        nom,      // Ajoutez cette ligne
        prenom    // Ajoutez cette ligne
      },
    });

    res.status(200).json(updated);
  } catch (err) {
    console.error("Erreur modification employ√© :", err);
    res.status(500).json({ error: "Erreur lors de la modification" });
  }
};

const getDashboardStats = async (req, res) => {
  try {
    const today = new Date();
    // D√©but de journ√©e (locale) - ajuster pour timezone UTC
    const startOfToday = new Date(today);
    startOfToday.setHours(0, 0, 0, 0);
    
    // Pour le taux de pointage, utiliser une fen√™tre plus large qui inclut la journ√©e pr√©c√©dente
    // pour capter les pointages qui peuvent √™tre d√©cal√©s par timezone
    const startPointage = new Date(startOfToday);
    startPointage.setDate(startPointage.getDate() - 1);
    startPointage.setHours(22, 0, 0, 0); // Depuis 22h hier (00h local)
    
    const finPointage = new Date(startOfToday);
    finPointage.setDate(finPointage.getDate() + 1);
    finPointage.setHours(6, 0, 0, 0); // Jusqu'√† 06h demain
    
    const now = today;    // Gestion de la p√©riode depuis les param√®tres de requ√™te
    const { periode = 'mois' } = req.query;
    const startDate = new Date(startOfToday);
    
    switch (periode) {
      case 'semaine':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case 'mois':
        startDate.setMonth(startDate.getMonth() - 1);
        break;
      case 'trimestre':
        startDate.setMonth(startDate.getMonth() - 3);
        break;
      case 'annee':
        startDate.setFullYear(startDate.getFullYear() - 1);
        break;
    }

    // Donn√©es de base
    const employes = await prisma.user.count({ where: { role: 'employee' } });

    // Pointages (arriv√©es) de la journ√©e (fen√™tre timezone-aware) pour calcul du taux
    const pointesAujourdHui = await prisma.pointage.findMany({
      where: {
        horodatage: { gte: startPointage, lte: finPointage },
        type: 'arrivee'
      },
      distinct: ['userId']
    });

    // Calcul sur les 7 derniers jours pour les heures travaill√©es
    const last7Days = new Date();
    last7Days.setDate(last7Days.getDate() - 7);
    last7Days.setHours(0, 0, 0, 0);

    // Calcul des heures travaill√©es aujourd'hui seulement
  // Fen√™tre heures travaill√©es (identique logique) : aujourd'hui 00:00 -> demain 06:00
  const tomorrow = new Date(startOfToday);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const finEtendue = new Date(tomorrow);
  finEtendue.setHours(6,0,0,0);
  const tempsPresenceAujourdhui = await calculerTotalHeures(startOfToday, finEtendue);

    // Demandes en attente
    const demandesAttente = await prisma.conge.count({
      where: { statut: 'en attente' },
    });

    // Cong√©s ce mois-ci
    const premierDuMois = new Date(startOfToday.getFullYear(), startOfToday.getMonth(), 1);
    const congesCeMois = await prisma.conge.count({
      where: {
        dateDebut: { gte: premierDuMois },
      },
    });

    // R√©partition des types de cong√©s (pour la p√©riode s√©lectionn√©e)
    const congesPeriode = await prisma.conge.findMany({
      where: {
        dateDebut: { gte: startDate },
        dateFin: { lte: today },
      },
    });

    const congesParType = {};
    congesPeriode.forEach((c) => {
      const nbJours = Math.ceil(
        (new Date(c.dateFin) - new Date(c.dateDebut)) / (1000 * 60 * 60 * 24) + 1
      );
      if (!congesParType[c.type]) {
        congesParType[c.type] = 0;
      }
      congesParType[c.type] += nbJours;
    });

    const repartitionConges = Object.entries(congesParType).map(([type, jours]) => ({
      type,
      jours,
    }));

    // Statuts des demandes (pour la p√©riode s√©lectionn√©e)
    const statuts = await prisma.conge.groupBy({
      by: ['statut'],
      _count: true,
      where: {
        dateDebut: { gte: startDate },
        dateFin: { lte: today },
      },
    });

    const statutsDemandes = statuts.map((s) => ({
      statut: s.statut.charAt(0).toUpperCase() + s.statut.slice(1),
      value: s._count,
      color: s.statut === 'approuv√©' || s.statut === 'approuve' ? '#10B981' : 
             s.statut === 'en attente' ? '#FBBF24' : '#cf292c'
    }));

    // √âvolution du taux de pr√©sence (simulation bas√©e sur les donn√©es r√©elles)
    const evolutionPresence = await genererEvolutionPresence();

    const congesSemaine = await prisma.conge.count({
      where: {
        dateDebut: { gte: today },
        dateFin: { lte: new Date(new Date().setDate(startOfToday.getDate() + 7)) },
      },
    });

    const prochainsConges = await prisma.conge.findMany({
      where: { dateDebut: { gte: today } },
      include: { user: true },
      take: 5
      // Comment√© temporairement pour debugger l'erreur colonne
      // orderBy: { dateDebut: 'asc' },
    });

    // üëÅÔ∏è Calculs pour la section "√Ä surveiller" - Donn√©es hebdomadaires pertinentes
    
    // P√©riode : d√©but de semaine (lundi) au jour actuel
    const debutSemaine = new Date();
    const joursDepuisLundi = (debutSemaine.getDay() + 6) % 7; // 0 = lundi, 6 = dimanche
    debutSemaine.setDate(debutSemaine.getDate() - joursDepuisLundi);
    debutSemaine.setHours(0, 0, 0, 0);
    
    console.log(`üìÖ P√©riode surveillance: ${debutSemaine.toLocaleDateString()} au ${today.toLocaleDateString()}`);
    
    // 1. Employ√©s absents cette semaine (aucun pointage d'arriv√©e)
    const employesAvecPointages = await prisma.pointage.findMany({
      where: {
        horodatage: { gte: debutSemaine, lte: today },
        type: 'arrivee'
      },
      select: { userId: true },
      distinct: ['userId']
    });
    
    // S'assurer que le nombre d'employ√©s absents ne peut pas √™tre n√©gatif
    const employesAbsents = Math.max(0, employes - employesAvecPointages.length);
    
    // 2. Employ√©s avec retards r√©p√©t√©s cette semaine 
    // Compter les employ√©s qui ont eu au moins un pointage d'arriv√©e tardif
    const employesAvecRetards = await prisma.pointage.findMany({
      where: {
        horodatage: { gte: debutSemaine, lte: today },
        type: 'arrivee',
      },
      select: { 
        userId: true,
        horodatage: true 
      }
    });
    
    // Simulation : consid√©rer qu'un employ√© est en retard s'il pointe apr√®s 9h
    const employsRetardsSet = new Set();
    employesAvecRetards.forEach(pointage => {
      const heure = pointage.horodatage.getHours();
      if (heure >= 9) { // Retard si pointage √† 9h ou apr√®s
        employsRetardsSet.add(pointage.userId);
      }
    });
    
    const employesEnRetard = employsRetardsSet.size;
    
    // 3. Employ√©s avec √©cart entre heures pr√©vues et r√©alis√©es
    const shiftsWeek = await prisma.shift.count({
      where: {
        date: { gte: debutSemaine, lte: today }
      }
    });
    
    const pointagesWeek = await prisma.pointage.count({
      where: {
        horodatage: { gte: debutSemaine, lte: today }
      }
    });
    
    // Si moins de pointages que de shifts, certains employ√©s n'ont pas respect√© leur planning
    const employesEcartPlanning = shiftsWeek > 0 ? Math.max(0, Math.min(3, Math.floor((shiftsWeek - pointagesWeek) / 2))) : 0;

    // Si pas de donn√©es, retourner des donn√©es de d√©monstration
    if (employes === 0 && repartitionConges.length === 0 && statutsDemandes.length === 0) {
      return res.json(genererDonneesDemo());
    }

    res.json({
      employes,
      demandesAttente,
      congesCeMois,
      totalHeures: tempsPresenceAujourdhui,  // Heures travaill√©es aujourd'hui
      repartitionConges,
      statutsDemandes,
      evolutionPresence,
      pointes: pointesAujourdHui.length,
      congesSemaine,
      prochainsConges: prochainsConges.map(c => ({
        nom: c.user.nom && c.user.prenom ? `${c.user.prenom} ${c.user.nom}` : c.user.email,
        type: c.type,
        dateDebut: c.dateDebut,
        dateFin: c.dateFin,
      })),
      // Donn√©es pour la section "√Ä surveiller" - hebdomadaires
      surveillance: {
        employesAbsents: employesAbsents,
        employesEnRetard: employesEnRetard,
        employesEcartPlanning: employesEcartPlanning,
        totalElements: employesAbsents + employesEnRetard + employesEcartPlanning,
        periode: `du ${debutSemaine.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' })} au ${today.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' })}`
      },
      periode,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Erreur dans getDashboardStats:', error);
    // En cas d'erreur, retourner des donn√©es de d√©monstration
    res.status(200).json(genererDonneesDemo());
  }
};

const calculerTotalHeures = async (debut, fin) => {
  // Si pas de param√®tres, utiliser aujourd'hui
  const dateDebut = debut || new Date();
  const dateFinReel = fin || new Date();

  // Etendre l√©g√®rement la fen√™tre de fin (comme la vue journali√®re) pour capter les d√©parts tardifs
  const dateFin = new Date(dateFinReel);
  const dateFinEtendue = new Date(dateFin);
  dateFinEtendue.setHours(dateFinEtendue.getHours() + 6); // tol√©rance jusqu'√† 6h apr√®s

  // Logs r√©duits
  console.log(`[Heures] Fen√™tre ${dateDebut.toISOString()} -> ${dateFinEtendue.toISOString()}`);

  const pointages = await prisma.pointage.findMany({
    where: {
      horodatage: {
        gte: dateDebut,
        lte: dateFinEtendue
      },
    },
    orderBy: { horodatage: 'asc' },
  });

  if (pointages.length === 0) return '0h00';
  
  const pointagesParEmploye = {};

  for (const p of pointages) {
    if (!pointagesParEmploye[p.userId]) pointagesParEmploye[p.userId] = [];
    pointagesParEmploye[p.userId].push(p);
  }

  let totalMs = 0;
  const now = new Date();

  for (const userId in pointagesParEmploye) {
    const points = pointagesParEmploye[userId];

    for (let i = 0; i < points.length; i++) {
      const current = points[i];
      const next = points[i + 1];

      if (current.type === 'arrivee') {
        if (next && next.type === 'depart') {
          const dureeMs = new Date(next.horodatage) - new Date(current.horodatage);
          totalMs += dureeMs;
          const dureeH = Math.floor(dureeMs / 1000 / 60 / 60);
          const dureeMin = Math.floor((dureeMs / 1000 / 60) % 60);
          i++; // skip la paire
        } else if (!next) {
          // Pas de d√©part encore: comptabiliser jusqu'√† maintenant (session en cours)
            const dureeMs = now - new Date(current.horodatage);
            if (dureeMs > 0) {
              totalMs += dureeMs;
              const dureeH = Math.floor(dureeMs / 1000 / 60 / 60);
              const dureeMin = Math.floor((dureeMs / 1000 / 60) % 60);
            }
        }
      }
    }
  }

  if (totalMs <= 0) {
    console.log('üîç DEBUG HEURES: totalMs = 0 => retour 0h00');
    return '0h00';
  }
  const heures = Math.floor(totalMs / 1000 / 60 / 60);
  const minutes = Math.floor((totalMs / 1000 / 60) % 60);
  console.log(`üîç DEBUG HEURES: total calcul√© = ${heures}h${minutes.toString().padStart(2,'0')}`);
  return `${heures}h${minutes.toString().padStart(2, '0')}`;
};

// Fonction pour g√©n√©rer l'√©volution du taux de pr√©sence
const genererEvolutionPresence = async () => {
  const mois = ['Jan', 'F√©v', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Ao√ªt'];
  const evolutionPresence = [];
  
  for (let i = 0; i < 8; i++) {
    const date = new Date();
    date.setMonth(date.getMonth() - (7 - i));
    
    // Compter les pointages pour ce mois
    const debutMois = new Date(date.getFullYear(), date.getMonth(), 1);
    const finMois = new Date(date.getFullYear(), date.getMonth() + 1, 0);
    
    const pointagesMois = await prisma.pointage.count({
      where: {
        horodatage: { gte: debutMois, lte: finMois },
      },
    });
    
    // Calculer un taux bas√© sur l'activit√© (simulation)
    const tauxBase = 85;
    const variation = Math.floor(Math.random() * 15) - 7; // -7 √† +7
    const taux = Math.max(70, Math.min(100, tauxBase + variation + (pointagesMois > 0 ? 5 : 0)));
    
    evolutionPresence.push({
      mois: mois[date.getMonth()],
      taux,
    });
  }
  
  return evolutionPresence;
};

// Fonction pour g√©n√©rer des donn√©es de d√©monstration
const genererDonneesDemo = () => {
  return {
    demo: true,
    employes: 5,
    demandesAttente: 2,
    congesCeMois: 8,
    tempsPresence: '127h30',
    repartitionConges: [
      { type: 'Cong√©s pay√©s', jours: 12 },
      { type: 'Maladie', jours: 4 },
      { type: 'RTT', jours: 6 },
      { type: 'Autres', jours: 2 },
    ],
    statutsDemandes: [
      { statut: 'Approuv√©', value: 8, color: '#10B981' },
      { statut: 'En attente', value: 2, color: '#FBBF24' },
      { statut: 'Refus√©', value: 1, color: '#cf292c' },
    ],
    evolutionPresence: [
      { mois: 'Jan', taux: 86 },
      { mois: 'F√©v', taux: 89 },
      { mois: 'Mar', taux: 92 },
      { mois: 'Avr', taux: 87 },
      { mois: 'Mai', taux: 91 },
      { mois: 'Juin', taux: 95 },
      { mois: 'Juil', taux: 88 },
      { mois: 'Ao√ªt', taux: 93 },
    ],
    pointes: 2,
    congesSemaine: 1,
    prochainsConges: [
      { nom: 'Demo User', type: 'Cong√©s pay√©s', dateDebut: new Date(), dateFin: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) },
    ],
    periode: 'demo',
    timestamp: new Date().toISOString()
  };
};

module.exports = {
  creerEmploye,
  modifierEmploye,
  supprimerEmploye,
  getDashboardStats,
};
